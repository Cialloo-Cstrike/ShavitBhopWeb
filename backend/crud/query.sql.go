// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package crud

import (
	"context"
	"database/sql"
)

const findLatestCompletion = `-- name: FindLatestCompletion :many
SELECT
    pt.map,
    pt.track,
    pt.style,
    pt.time,
    u.name,
    u.ip,
    u.lastlogin,
    pt.date,
    pt.points,
    pt.jumps,
    pt.strafes,
    pt.sync,
    pt.perfs,
    pt.completions
FROM
    playertimes pt
    JOIN users u ON pt.auth = u.auth
GROUP BY
    pt.map,
    pt.track,
    pt.style,
    pt.time,
    u.name,
    u.ip,
    u.lastlogin,
    pt.date,
    pt.points,
    pt.jumps,
    pt.strafes,
    pt.sync,
    pt.perfs,
    pt.completions
ORDER BY
    pt.date DESC
LIMIT
    ? OFFSET ?
`

type FindLatestCompletionParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type FindLatestCompletionRow struct {
	Map         string          `json:"map"`
	Track       int8            `json:"track"`
	Style       int8            `json:"style"`
	Time        float64         `json:"time"`
	Name        sql.NullString  `json:"name"`
	Ip          sql.NullInt32   `json:"ip"`
	Lastlogin   int32           `json:"lastlogin"`
	Date        sql.NullInt32   `json:"date"`
	Points      float64         `json:"points"`
	Jumps       sql.NullInt32   `json:"jumps"`
	Strafes     sql.NullInt32   `json:"strafes"`
	Sync        sql.NullFloat64 `json:"sync"`
	Perfs       sql.NullFloat64 `json:"perfs"`
	Completions sql.NullInt16   `json:"completions"`
}

func (q *Queries) FindLatestCompletion(ctx context.Context, arg FindLatestCompletionParams) ([]FindLatestCompletionRow, error) {
	rows, err := q.db.QueryContext(ctx, findLatestCompletion, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindLatestCompletionRow
	for rows.Next() {
		var i FindLatestCompletionRow
		if err := rows.Scan(
			&i.Map,
			&i.Track,
			&i.Style,
			&i.Time,
			&i.Name,
			&i.Ip,
			&i.Lastlogin,
			&i.Date,
			&i.Points,
			&i.Jumps,
			&i.Strafes,
			&i.Sync,
			&i.Perfs,
			&i.Completions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findLatestCompletionWithTrackAndStyle = `-- name: FindLatestCompletionWithTrackAndStyle :many
SELECT
    pt.map,
    pt.track,
    pt.style,
    pt.time,
    u.name,
    u.ip,
    u.lastlogin,
    pt.date,
    pt.points,
    pt.jumps,
    pt.strafes,
    pt.sync,
    pt.perfs,
    pt.completions
FROM
    playertimes pt
    JOIN users u ON pt.auth = u.auth
WHERE
    pt.track = ?
    AND pt.style = ?
GROUP BY
    pt.map,
    pt.track,
    pt.style,
    pt.time,
    u.name,
    u.ip,
    u.lastlogin,
    pt.date,
    pt.points,
    pt.jumps,
    pt.strafes,
    pt.sync,
    pt.perfs,
    pt.completions
ORDER BY
    pt.date DESC
LIMIT
    ? OFFSET ?
`

type FindLatestCompletionWithTrackAndStyleParams struct {
	Track  int8  `json:"track"`
	Style  int8  `json:"style"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type FindLatestCompletionWithTrackAndStyleRow struct {
	Map         string          `json:"map"`
	Track       int8            `json:"track"`
	Style       int8            `json:"style"`
	Time        float64         `json:"time"`
	Name        sql.NullString  `json:"name"`
	Ip          sql.NullInt32   `json:"ip"`
	Lastlogin   int32           `json:"lastlogin"`
	Date        sql.NullInt32   `json:"date"`
	Points      float64         `json:"points"`
	Jumps       sql.NullInt32   `json:"jumps"`
	Strafes     sql.NullInt32   `json:"strafes"`
	Sync        sql.NullFloat64 `json:"sync"`
	Perfs       sql.NullFloat64 `json:"perfs"`
	Completions sql.NullInt16   `json:"completions"`
}

func (q *Queries) FindLatestCompletionWithTrackAndStyle(ctx context.Context, arg FindLatestCompletionWithTrackAndStyleParams) ([]FindLatestCompletionWithTrackAndStyleRow, error) {
	rows, err := q.db.QueryContext(ctx, findLatestCompletionWithTrackAndStyle,
		arg.Track,
		arg.Style,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindLatestCompletionWithTrackAndStyleRow
	for rows.Next() {
		var i FindLatestCompletionWithTrackAndStyleRow
		if err := rows.Scan(
			&i.Map,
			&i.Track,
			&i.Style,
			&i.Time,
			&i.Name,
			&i.Ip,
			&i.Lastlogin,
			&i.Date,
			&i.Points,
			&i.Jumps,
			&i.Strafes,
			&i.Sync,
			&i.Perfs,
			&i.Completions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findLatestWr = `-- name: FindLatestWr :many
SELECT
    pt.map,
    pt.track,
    pt.style,
    MIN(pt.time) AS min_time,
    u.name,
    u.ip,
    u.lastlogin,
    pt.date,
    pt.points,
    pt.jumps,
    pt.strafes,
    pt.sync,
    pt.perfs,
    pt.completions
FROM
    playertimes pt
    JOIN users u ON pt.auth = u.auth
WHERE
    pt.time = (
        SELECT
            MIN(pt2.time)
        FROM
            playertimes pt2
        WHERE
            pt2.map = pt.map
            AND pt2.track = pt.track
            AND pt2.style = pt.style
    )
GROUP BY
    pt.map,
    pt.track,
    pt.style,
    u.name,
    u.ip,
    u.lastlogin,
    pt.date,
    pt.points,
    pt.jumps,
    pt.strafes,
    pt.sync,
    pt.perfs,
    pt.completions
ORDER BY
    pt.date DESC
LIMIT
    ? OFFSET ?
`

type FindLatestWrParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type FindLatestWrRow struct {
	Map         string          `json:"map"`
	Track       int8            `json:"track"`
	Style       int8            `json:"style"`
	MinTime     interface{}     `json:"minTime"`
	Name        sql.NullString  `json:"name"`
	Ip          sql.NullInt32   `json:"ip"`
	Lastlogin   int32           `json:"lastlogin"`
	Date        sql.NullInt32   `json:"date"`
	Points      float64         `json:"points"`
	Jumps       sql.NullInt32   `json:"jumps"`
	Strafes     sql.NullInt32   `json:"strafes"`
	Sync        sql.NullFloat64 `json:"sync"`
	Perfs       sql.NullFloat64 `json:"perfs"`
	Completions sql.NullInt16   `json:"completions"`
}

func (q *Queries) FindLatestWr(ctx context.Context, arg FindLatestWrParams) ([]FindLatestWrRow, error) {
	rows, err := q.db.QueryContext(ctx, findLatestWr, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindLatestWrRow
	for rows.Next() {
		var i FindLatestWrRow
		if err := rows.Scan(
			&i.Map,
			&i.Track,
			&i.Style,
			&i.MinTime,
			&i.Name,
			&i.Ip,
			&i.Lastlogin,
			&i.Date,
			&i.Points,
			&i.Jumps,
			&i.Strafes,
			&i.Sync,
			&i.Perfs,
			&i.Completions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findLatestWrWithTrackAndStyle = `-- name: FindLatestWrWithTrackAndStyle :many
SELECT
    pt.map,
    pt.track,
    pt.style,
    MIN(pt.time) AS min_time,
    u.name,
    u.ip,
    u.lastlogin,
    pt.date,
    pt.points,
    pt.jumps,
    pt.strafes,
    pt.sync,
    pt.perfs,
    pt.completions
FROM
    playertimes pt
    JOIN users u ON pt.auth = u.auth
WHERE
    pt.time = (
        SELECT
            MIN(pt2.time)
        FROM
            playertimes pt2
        WHERE
            pt2.map = pt.map
            AND pt2.track = pt.track
            AND pt2.style = pt.style
    )
    AND pt.track = ?
    AND pt.style = ?
GROUP BY
    pt.map,
    pt.track,
    pt.style,
    u.name,
    u.ip,
    u.lastlogin,
    pt.date,
    pt.points,
    pt.jumps,
    pt.strafes,
    pt.sync,
    pt.perfs,
    pt.completions
ORDER BY
    pt.date DESC
LIMIT
    ? OFFSET ?
`

type FindLatestWrWithTrackAndStyleParams struct {
	Track  int8  `json:"track"`
	Style  int8  `json:"style"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type FindLatestWrWithTrackAndStyleRow struct {
	Map         string          `json:"map"`
	Track       int8            `json:"track"`
	Style       int8            `json:"style"`
	MinTime     interface{}     `json:"minTime"`
	Name        sql.NullString  `json:"name"`
	Ip          sql.NullInt32   `json:"ip"`
	Lastlogin   int32           `json:"lastlogin"`
	Date        sql.NullInt32   `json:"date"`
	Points      float64         `json:"points"`
	Jumps       sql.NullInt32   `json:"jumps"`
	Strafes     sql.NullInt32   `json:"strafes"`
	Sync        sql.NullFloat64 `json:"sync"`
	Perfs       sql.NullFloat64 `json:"perfs"`
	Completions sql.NullInt16   `json:"completions"`
}

func (q *Queries) FindLatestWrWithTrackAndStyle(ctx context.Context, arg FindLatestWrWithTrackAndStyleParams) ([]FindLatestWrWithTrackAndStyleRow, error) {
	rows, err := q.db.QueryContext(ctx, findLatestWrWithTrackAndStyle,
		arg.Track,
		arg.Style,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindLatestWrWithTrackAndStyleRow
	for rows.Next() {
		var i FindLatestWrWithTrackAndStyleRow
		if err := rows.Scan(
			&i.Map,
			&i.Track,
			&i.Style,
			&i.MinTime,
			&i.Name,
			&i.Ip,
			&i.Lastlogin,
			&i.Date,
			&i.Points,
			&i.Jumps,
			&i.Strafes,
			&i.Sync,
			&i.Perfs,
			&i.Completions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findTopPlayerPoint = `-- name: FindTopPlayerPoint :many
SELECT
    auth, name, ip, lastlogin, points, playtime
FROM
    users
ORDER BY
    points DESC
LIMIT
    ? OFFSET ?
`

type FindTopPlayerPointParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) FindTopPlayerPoint(ctx context.Context, arg FindTopPlayerPointParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, findTopPlayerPoint, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.Auth,
			&i.Name,
			&i.Ip,
			&i.Lastlogin,
			&i.Points,
			&i.Playtime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
